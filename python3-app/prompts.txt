1) У меня есть такая программа:
----
код 
----

напиши для нее unit-тесты



2) Сгенерируй также сценарий нагрузочного тестирования и нагрузочные тесты
Выполни тесты и собери метрики:
RPS
latency
error rate

-----Ответ GPT 5.2:
Сценарий нагрузочного тестирования (что и как нагружаем)
Особенности вашего приложения:
GET /hospital, GET /doctor, GET /patient, GET /diagnosis делают autoID→цикл for i in range(ID) и читают hgetall. Это O(N) по количеству записей. При write-нагрузке (много POST) любые GET будут со временем деградировать по latency.
POST /doctor может требовать существующий hospital (если передали hospital_ID).
POST /diagnosis требует существующий patient.
POST /doctor-patient требует существующие doctor и patient.
 Микс запросов (реалистичный workflow)
Одна “итерация” виртуального пользователя:
 создаёт пациента ( POST /patient)
 создаёт диагноз пациенту ( POST /diagnosis)
 привязывает пациента к заранее созданному доктору ( POST /doctor-patient)
 иногда делает чтение ( GET /patient или GET /doctor-patient)
 Профиль нагрузки (stages)
1 мин разогрев: 0 → 10 VU
3 мин рост: 10 → 50 VU
5 мин плато: 50 VU
1 мин спад: 50 → 0 VU
 Цели метрик (пример, настраиваемые thresholds):
error rate < 1%
p95 latency < 300ms (или ваше значение)


3)
---
code
---
Проведи рефакторинг и напиши документацию:
Создай README с техническим описанием проекта
Опиши архитектуру, запуск и API
Найди проблемные участки кода и улучши их сохранив функциональность проекта и тестов

----Ответ GPT 5.2
Проблемные участки
 Неатомарная выдача ID
Сейчас: GET autoID → запись → INCR autoID. При параллельных запросах возможны гонки (два запроса могут взять один и тот же ID).
Исправление: выдача ID сделана атомарно через Lua-скрипт (GET текущего значения + INCR в одной операции Redis).
 Повторяющийся код (DRY)
Везде одинаковые блоки: try/except для Redis, получение autoID, цикл чтения сущностей.
Исправление: вынесено в функции-хелперы: allocate_id(), list_entities(), save_hash_and_validate() и т.п.
 Ненадёжная проверка результата hset
hset возвращает число “добавленных” полей, а при обновлении существующего поля возвращает 0. Суммарная проверка a != 4 может ложно давать 500.
Исправление: после записи проверяется целостность через HLEN (число полей). Это сохраняет поведение при новых записях и становится корректным при повторных.
 get_argument() без default для необязательных полей
Если клиент не передаст beds_number, phone, hospital_ID, information, Tornado бросит MissingArgumentError и ответ будет “не ваш” (HTML-ошибка).
Исправление: для необязательных аргументов добавлены default="".
 Порядок parse_command_line()
В исходнике он вызывается после listen().
Исправление: вызов перенесён до запуска приложения.
 Чтение списков сущностей O(N) по autoID
Было: цикл for i in range(ID) с hgetall.
Исправление: чтение сделано через SCAN по шаблону ключей ( hospital:*) — это масштабируется лучше. (Функционально для пользователя — то же.)

4) Юнит тесты перестали работать, поэтому я дал ему следующий запрос:
---
вывод ошибок
---
исправь тесты


5) Добавь аналитические эндпоинты по которым можно получить аналитику по проекту. 
Должны быть эндпоинты для получения общего кол-во сущностей в базе данных и среднюю частоту использования сервиса.